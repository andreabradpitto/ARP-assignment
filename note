Per verificare la sine wave importa il log file in un csv (separata tutto con spazi o con virgole)
scrivere nel readme o da qualche parte che se ti dice exec: permission denied, ci vuole un chmod +x per gli eseguibili
rinomina main in launcher o start o boh
sposta magari in cartella obj gli eseguibili a parte main, anche il log lì forse
"dato che durante il debugging ho creato un output su schermo solido e convincente, ho deciso di cambiare leggermente il senso di log print"
dovrò fare rimozione librerie non usate
leggi pdf prima di consegnare e anche la nota di Keep. Consegna su aulaweb e scrivi mail (con link a Github)



Nota Keep:

Hello, I think we should decide certain parameters for the ARP assignment, so when we get to the test we all have the same configuration for the pipes between P and G. Zaccaria explicitly said it's your business, so when you get to the exam  you have to manage whatever the guy before you gives you as G. So I think it would be smart to agree on the same type of data to be passed from G to P.
I would propose a char array with just a float inside as it would be the most standard type of data.

IDEA: tutta la roba che passo la metto come stringa dentro la pipe, cosi posso codificare parole, tipo "stop" o "start" mentre rimangono float i campioni delle sinusoidi. rimane da capire se devo fare il riconoscimento dei due dati diversi per chi li legge oppure se appunto seguire questa nuova idea e unificare ogni dato sotto lo stesso tipo, a patto che siano distinguibili

-----------------------------------------------------------------------------

problemi da affrontare:
-tipi di dato per la connessione 1 o 2 (vedi anche marco)
-computazione della sine wave
-atoi e altri
-velocità di dati connessione

oppure posso passare il messaggio del tipo di fra, con me stesso funziona bene. se ricevo dall'esterno devo comporre io la struct: quello che arriva è da mettere in g (char), il resto ce lo aggiungo. o al massimo metti a posto l'header prima di farlo girare


-----------------------------------------------------------------------------


devo ricostruirmi in tutto P l'invio dei messaggi a L:
da un lato ho un int, dall'altro un float
mando un message con vari campi (timestamp (se non lo prendo in log), float, int)

P: metti tutto in struct quando manda a L, dalle pipe sopra 1 riceve int altro char con float dentro + timestamp
L: adatta a ricezione della struct
G: manda dei float + timestamp

per ovviare i problemi in L posso fare che viene sempre letto prima lo stato (int), metto tipo 99 per identificare che e un msg dalla pipe 2

come faccio dal punto di vista di L a riconoscere i pezzi della struct? chiedi a matteo

marco ha usato solo exec anche per lanciare nodo S

Devo ricontrollare come passo la roba, le varie & e se sono coerente a mettere in un buffer solo un float poi da altre parti passo tutta la struct msg, insomma faccio casino


-----------------------------------------------------------------------------
FASE DI DEBUG

se rimuovo da G la riga della pipe per L, incomincio a vedere p1 p2 P sent a message, ma perdo il controllo del terminale. G non pubblica più, perchè prima aveva pubblicato sul terminale e poi non più.

ricontrolla il core della comunicazione, ovvero il tipo di messaggio passato e come viene passato tramite le write e le read

importante: al momento in debug ho tolto sent first message di P, per mettere un controllo tipo "first". Attenzione un problema potrebbe essere che G prova comunque a leggere prima che ci sia il primo dato di P, il che non so nemmeno sia un problema. In effetti forse no perchè quella è una socket all'inzio, non una read da una pipe

devo provare a togliere tutto e lasciare solo un main che lancia un P e un G che si parlano

MA NON è che il wait status nel main fa chiudere tutto?


-----------------------------------------------------------------------------


https://stackoverflow.com/questions/9596945/how-to-get-appropriate-timestamp-in-c-for-logs

https://en.cppreference.com/w/c/chrono/time_t

https://en.cppreference.com/w/c/chrono/asctime

https://unix.stackexchange.com/questions/11953/make-a-log-file

https://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html

https://www.thegeekstuff.com/2011/02/send-signal-to-process/

https://bash.cyberciti.biz/guide/Sending_signal_to_Processes

http://manpages.ubuntu.com/manpages/xenial/man2/select_tut.2.html

https://stackoverflow.com/questions/22122615/reading-multiple-messages-using-pipe-in-c?rq=1

https://stackoverflow.com/questions/41064157/c-sending-struct-array-over-pipe

-----------------------------------------------------------------------------

Da altra nota:
I have actually the same scheme for the select() function as the one in: https://stackoverflow.com/questions/28519119/c-using-select-to-read-from-two-named-pipes-fifo?rq=1
In my case, one of the read() is used to read from a pipe, which sends data coming from a socket, while the other read() reads from another pipe, that should send data coming from another terminal (see below). The second one is not working properly, since as I send one input from that other terminal, the other end of the pipe keeps acknowledging new data coming and I thus get my standard output flooded with wrong prints of the same only input I sent.
Granted that my select has the same structure as the one in the link, I'll now show the other relevant code lines I use  ``` int exit_status = system("gnome-terminal"); ``` on another 


cita la tua domanda, o forse meglio copia la intro della mia stessa domanda

-----------------------------------------------------------------------------

2021:
test for posix shell compliance:
https://stackoverflow.com/questions/28654973/test-for-posix-shell-compliance
